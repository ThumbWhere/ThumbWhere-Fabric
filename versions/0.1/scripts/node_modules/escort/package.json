{
  "name": "escort",
  "version": "0.0.13",
  "description": "Routing and URL generation middleware",
  "keywords": [
    "framework",
    "web",
    "middleware",
    "connect",
    "escort",
    "routing",
    "url"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/ckknight/escort.git"
  },
  "author": {
    "name": "Cameron Kenneth Knight",
    "email": "ckknight@gmail.com",
    "url": "http://ckknight.com"
  },
  "dependencies": {},
  "main": "index",
  "engines": {
    "node": ">= 0.4.1 < 0.5.0"
  },
  "readme": "# Escort\n\n  Escort is a middleware for [Connect](https://github.com/senchalabs/connect) which provides routing and url generation\n  capabilities.\n\n## Installation\n  \n  The easiest way to install is through [npm](http://npmjs.org/).\n  \n    $ npm install escort\n  \n  Alternatively, you can pull from [github](https://github.com/ckknight/escort) and place where necessary.\n\n## What makes Escort different from other routing libraries\n  \n  * URL generation\n    \n    Because routing from URLs to callbacks is only half of the problem, you also need to generate URLs.\n    \n    Hardcoding the URLs (in your views, likely) can be a pain to update if ever your URLs. Also, if you have dynamic\n    URLs, knowing the correct and safe syntax to convert the Javascript values to a safe URL can be tricky.\n    \n  * Converters\n  \n    Converters provide a way to safely and consistently handle dynamic route parameter consumption and generation.\n    \n    Rather than defining regular expression yourself or manually converting URL strings to other JavaScript\n    objects, the converter takes care of all of that for you.\n    \n    Also, it knows how to convert the JavaScript objects provided back into safe URL components with ease.\n    \n  * Submounting\n    \n    Logically divide segments of your app into different route submounts.\n    \n  * Case-agnostic but aware\n  \n    Although domains are case-insensitive, URLs are not. `/foo` is a different URL from `/FOO` and from `/Foo`, and your\n    SEO (Search Engine Optimization) can be hurt by having all three serve the same content (assuming they're referenced\n    from other pages). Also, having your expected url (e.g. `/foo`) work but the other casings not work can be confusing\n    for users in certain cases.\n    \n    Escort takes the approach of allowing all three URLs to work, but if it is not exactly case equivalent to the\n    expected route, then a 301 Moved Permanently will redirect to the correct one. This means that if someone visits\n    `/FOO`, they are immediately redirected to `/foo`. Since it is a 301, any SEO rankings should also update.\n  \n  * Unicode-aware\n  \n    You are fully able to have unicode parts in your URLs without harm, and you register them as if they are normal\n    paths. You can also very capably accept unicode parts in the dynamic parameters as well.\n    \n  * Performance concerns\n    \n    Routing tends to be hit every request, since any caching that occurs typically starts inside one's route callback.\n    Thus, making route consumption as efficient as possible is a key priority.\n    \n    Routes are separated into static and dynamic routes. Static routes are implicitly efficient,\n    since it is just a quick Object key lookup (which V8) has very optimized.\n    \n    Dynamic routes are trickier and Escort has a two-phase approach for consuming them.\n    \n    First, every time a route is properly calculated, its callback and generated parameters are stored in an in-memory\n    cache keyed on its URL. That means that if someone were to visit any particular URL more than once (before the\n    cache clears), the routing system only has to do the calculation once rather than each time.\n    \n    Secondly, for the actual calculation of the route, it separates out all routes based on their prefixes. Since all\n    prefixes are guaranteed to be static (even if it is just `/`), doing an efficient non-RegExp check for whether the\n    incoming URL matches the prefix will cut down lookups by a significant amount in the general case (varying from app\n    to app). Not having to traverse all the `/pages/` routes for something that we know is under `/forums/` removes a\n    significant amount of work.\n  \n  * Client-side URL generation\n    \n    Escort provides a way to serialize its URL structure such that a client-side library can interpret that JSON data\n    and be able to generate URLs. This is extremely handy if you have a web app where you generate HTML rather than\n    leave it up to the server.\n    \n    The `escort-client.js` is provided for you that can be used in the browser.\n\n## Hello, world!\n  \n  This will assume you already have [Connect](https://github.com/senchalabs/connect) installed.\n  \n  This should be the absolutely simplest program, a simple app that listens on `localhost:3000` and says\n  `\"Hello, world!\"` when you visit its root (`/`).\n  \n    var connect = require('connect'),\n        escort = require('escort');\n      \n    connect(\n        escort(function(routes) {\n            routes.get(\"/\", function(req, res) {\n                res.end(\"Hello, world!\");\n            });\n        })\n    ).listen(3000);\n\n  It will only respond when a `GET` is sent to `/`. If you were to send a `POST`, it would not respond be providing\n  `\"Hello, world!\"`. Also, if you were to visit any other URL, it wouldn't respond either, since those have not been\n  bound yet.\n  \n  *Note: the routes parameter can be removed in favor of using `this`, as in the following example*\n  \n    connect(\n        escort(function() {\n            this.get(\"/\", function(req, res) {\n                res.end(\"Hello, world!\");\n            });\n        })\n    ).listen(3000);\n\n## Dynamic parameters\n\n  Not every route can or should be statically-defined. After all, what's the point of writing a fluid, dynamic\n  application if we were limited to that?\n  \n  Thus, we need to be able to have dynamic parameters in our routes. In Escort, they are specified through the syntax\n  `{param}`.\n  \n    connect(\n        escort(function(routes) {\n            routes.get(\"/\", function(req, res) {\n                res.end(\"Hello, world!\");\n            });\n            routes.get(\"/{name}\", function(req, res, params) {\n                res.end(\"Hello, \" + params.name + \"!\");\n            });\n        })\n    ).listen(3000);\n  \n  Visiting `/` still sends you `\"Hello, world!\"`, but visiting `/ckknight` will now send you `\"Hello, ckknight!\"`\n  instead of just giving a 404.\n\n## URL generation\n\n  Just as one can visit a URL and have it properly route to a callback to run which powers our apps, often we want the\n  reverse: being able to generate URLs.\n    \n    connect(\n        escort(function(routes) {\n            var url = routes.url;\n            \n            routes.get(\"/\", function(req, res) {\n                res.end(\"You are visiting \" + url.root());\n            })\n            routes.get(\"/about\", function(req, res) {\n                res.end(\"You are visiting \" + url.about());\n            })\n            routes.get(\"pageIndex\", \"/pages\", function(req, res) {\n                res.end(\"You are visiting \" + url.pageIndex());\n            })\n            routes.get(\"page\", \"/pages/{pageSlug}\", function(req, res, params) {\n                res.end(\"You are visiting \" + url.page({ pageSlug: params.pageSlug }));\n                // alternatively, url.page(params.pageSlug)\n            })\n        })\n    ).listen(3000);\n  \n  In the first two routes, the `routeName` is generated automatically for each. The system tries to guess, but it's not\n  perfect in every case. In the cases where you either don't like what it guesses or if it is unable to, you can specify\n  your own name for the route, which is done in the latter two cases.\n  \n  This `routeName` is then used to generate a function on the `url` object. For static routes, to parameters are\n  required or expected, but for dynamic routes, either an Object must be passed in or the in-order parameters expected.\n\n## Multiple methods\n\n  Unlike some other routing libraries, if you wish to bind a URL to multiple methods, it must all be done so at the same\n  time using the bind function. This is done because every unique route has a unique name, regardless of the methods\n  that it accepts.\n    \n    connect(\n        escort(function(routes) {\n            routes.bind(\"users\", \"/users\", {\n                get: function(req, res) {\n                    res.end(\"Show a list of users\");\n                },\n                post: function(req, res) {\n                    res.end(\"Successfully created a new user!\");\n                }\n            });\n            \n            routes.bind(\"user\", \"/users/{username}\", {\n                get: function(req, res, params) {\n                    res.end(\"Found user \" + params.username);\n                },\n                put: function(req, res, params) {\n                    res.end(\"Updated user \" + params.username);\n                }\n            })\n        })\n    ).listen(3000);\n  \n  Each route in this case has two methods it listens to. `/users` matches `GET` and `POST`, which RESTfully lists the\n  users and creates a new user, respectively. `/users/{username}` matches `GET` and `PUT`, which RESTfully details the\n  user and updates the existing user, respectively.\n\n### Calling other methods\n\n  One particularly useful usage pattern that comes particularly in handy when making an HTML app (as opposed to a\n  JSON-driven app) is having the `GET` and `POST` (or `PUT`) actions run through the same code in the following manner:\n  \n    connect(\n        escort(function(routes) {\n            routes.bind(\"createPost\", \"/posts/create\", {\n                get: function(req, res) {\n                    this.post(req, res);\n                },\n                post: function(req, res) {\n                    var form = parseForm(req);\n                    if (!form.isValid()) {\n                        res.end(\"Render the form here, show validation errors.\");\n                        return;\n                    }\n                    // create the post\n                    res.end(\"Successfully created a new post!\");\n                }\n            });\n        })\n    ).listen(3000);\n  \n  What this allows is for your `GET` request to render a form (without validation errors, since it's a blank slate), and\n  allow your `POST` request to validate the form, if valid, create, if invalid, re-render the form (with helpful\n  validation errors).\n  \n  _Please note that this leaves a lot of code up to the user, such as the form validation and the actual HTML\n  rendering_.\n\n### Multiple methods with the same callback\n\n  If you'd rather not just call `this.post`, you can easily specify that multiple methods are serviced by a single\n  callback.\n  \n    connect(\n        escort(function(routes) {\n            routes.bind(\"createPost\", \"/posts/create\", {\n                \"get,post\": function(req, res) {\n                    res.end(req.method + \" /posts/create\");\n                }\n            });\n        })\n    ).listen(3000);\n  \n  This will bind `/posts/create` to listen on both `GET` and `POST`.\n\n## Converters\n\n  For dynamic routes, different *converters* may be used for each dynamic parameter, each with their own capabilities\n  and options.\n  \n  The default is the `string` converter, which is used when one is not specified.\n  \n  * `string` - Parses any string that does not have a slash (`/`) in it. Can specify `minLength`, `maxLength`, and\n               `allowUpperCase`.\n  * `int` - Parses a numeric string. Converts to and from *Number*. Can specify `min`, `max`, and `fixedDigits`.\n  * `path` - Parses any string, even those with slashes (`/`) in them. Useful for wikis. Can specify `allowUpperCase`.\n  * `any` - Parses one of a specified set of strings.\n  \n  ----\n    connect(\n        escort(function(routes) {\n            routes.get(\"post\", \"/posts/{postSlug:string}\", function(req, res, params) {\n                // exact same as \"/posts/{postSlug}\"\n                res.end(\"GET /posts/\" + params.postSlug);\n            });\n\n            routes.get(\"user\", \"/users/{username:string({minLength: 3, maxLength: 8, allowUpperCase: true})}\", function(req, res, params) {\n                res.end(\"GET /users/\" + params.username);\n            });\n\n            routes.get(\"thread\", \"/thread/{threadID:int({min: 1})}\", function(req, res, params) {\n                // params.threadID is a Number, not a String\n                res.end(\"GET /thread/\" + params.threadID);\n            });\n\n            routes.get(\"archiveYear\", \"/archive/{year:int({fixedDigits: 4})}\", function(req, res, params) {\n                res.end(\"Archive for year: \" + params.year);\n            });\n\n            routes.get(\"wikiPage\", \"/wiki/{page:path}\", function(req, res, params) {\n                res.end(\"GET /page/\" + params.page);\n            });\n\n            routes.get(\"info\", \"/{page:any('about', 'contact')}\", function(req, res, params) {\n                res.end(\"GET /\" + params.info);\n            });\n        })\n    ).listen(3000);\n  \n  `/posts/some-post` does as expected, since `string` is the default converter anyway. `/posts/some-post/deep` will not,\n  as the slash (`/`) in it makes the route not recognize it properly.\n  \n  `/users/hi` will return a 404, won't ever even hit the route, since `hi` is too short. `/users/toolongofaname` will\n  also return a 404, since `toolongofaname` is too long. `/users/SomeGuy` will work perfectly fine.\n  \n  `/thread/some-thread` will return a 404, since `some-thread` isn't a number. `/thread/0` also returns a 404, since 0\n  is less than the specified minimum of 1. `/thread/1` works fine, as does `/thread/1000000000`.\n  \n  `/archive/123` will return a 404, since `123` isn't 4 digits. Contrarily, `/archive/0123` will work fine, as well as\n  the expected `/archive/1960`.\n  \n  `/wiki/some-page` will work fine, as well as `/wiki/some-page/discussion`.\n  \n  Both `/about` and `/contact` will match the *info* route, but no others will.\n\n### Custom converters\n  \n  If you are so inclined (95% of apps out there probably aren't) to define your own converter, it's relatively easy.\n  \n  You merely have to define a function which returns an object that has the following interface:\n  \n    {\n        weight: 100, // optional, if not provided, defaults to 100 regardless\n        regex: \"[^/]+\", // must be a string, not a RegExp\n        fromUrl: function (value) {\n            // return any _immutable_ value, can be any Javascript element, even Object, Array, or Function (as long as\n            // they're frozen).\n            return value;\n        },\n        toUrl: function (value) {\n            // return a String\n            return encodeURIComponent(value);\n        },\n        serialize: function () {\n            return { type: \"customName\" };\n        }\n    }\n  \n  If you wish to, you can inherit from `escort.BaseConverter`, but it's not necessary.\n  \n  Here is an example converter:\n  \n    var BooleanConverter = function (trueName, falseName) {\n        if (!trueName) {\n            trueName = \"yes\";\n        }\n        if (!falseName) {\n            falseName = \"no\";\n        }\n        return {\n            regex: \"(?:\" + trueName + \"|\" + falseName + \")\",\n            fromUrl: function (value) {\n                return value === trueName;\n            },\n            toUrl: function (value) {\n                return value ? trueName : falseName;\n            },\n            serialize: function () {\n                return { type: \"bool\" };\n            }\n        };\n    };\n  \n  And here it is in action:\n  \n    var url;\n    connect(\n        escort({ converters: { bool: BooleanConverter } }, function(routes) {\n            url = routes.url;\n            \n            routes.get(\"check\", \"/check/{careful}\", function(req, res, params) {\n                res.end(params.careful\n                    ? \"Carefully checking\"\n                    : \"Playing solitaire, not actually checking\");\n            });\n            \n            routes.get(\"feed\", \"/feed/{goodFood:bool('good', 'bad')}\", function(req, res, params) {\n                if (params.goodFood) {\n                    res.end(\"Yay, good food!\");\n                } else {\n                    res.end(\"Gruel again :(\");\n                }\n            })\n        })\n    ).listen(3000);\n    \n    url.check(true) === \"/check/yes\";\n    url.check(false) === \"/check/no\";\n    url.feed(true) === \"/check/good\";\n    url.feed(false) === \"/check/bad\";\n  \n  So the param you get back is a **Boolean**, as the converter's `fromUrl` specifies. The `toUrl` function also properly\n  makes the url generation work and provide the reverse result.\n  \n  If you want to have the `default` converter not be `escort.StringConverter`, you can provide the `default` key with\n  your own.\n\n## Submounting\n  Often times, your app may have many parts to it that belong in their own route sections. Submounting is the perfect\n  answer for this (assuming you don't want to have multiple apps for each section). Submounting can also be used for\n  more rigorously defining the tree structure of your app.\n  \n  There is no performance downside to using submounting, it is merely a configuration nicety.\n  \n    connect(\n        escort(function(routes) {\n            url = routes.url;\n            \n            routes.submount(\"/pages\", function(pages) {\n                pages.get(\"\", function(req, res) {\n                    res.end(\"Page listing here\");\n                });\n                \n                this.submount(\"/{pageSlug}\", function() {\n                    this.get(\"page\", \"\", function(req, res, params) {\n                        res.end(\"Page details for \" + params.pageSlug);\n                    });\n                    \n                    this.bind(\"pageEdit\", \"/edit\", {\n                        get: function(req, res, params) {\n                            res.end(\"Editing page \" + params.pageSlug);\n                        },\n                        put: function(req, res, params) {\n                            res.end(\"Updating page \" + params.pageSlug);\n                        }\n                    });\n                });\n            });\n            \n            url.pages() === \"/pages\";\n            url.page(\"thing\") === \"/pages/thing\";\n            url.pageEdit(\"thing\") === \"/pages/thing/edit\";\n        })\n    ).listen(3000);\n\n  *Note: both `this` and the first argument of the `submount` callback are the same thing. Use whichever one you're\n  more comfortable with.*\n\n## Optional route segments\n  \n  In some cases, you may want to have optional segments as part of your routes, which is easily solvable through one of\n  two ways:\n  \n  You can provide two distinct routes to bind to:\n  \n    connect(\n        escort(function(routes) {\n            routes.get([\"/data\", \"/data.{format}\"], function(req, res, params) {\n                var format = params.format || \"html\";\n                \n                switch (format) {\n                    case \"html\":\n                        res.end(\"<p>Hey there</p>\");\n                        break;\n                    case \"json\":\n                        res.end(JSON.stingify(\"Hey there\"));\n                        break;\n                    default:\n                        res.writeHead(404);\n                        res.end();\n                        break;\n                }\n            })\n        })\n    ).listen(3000);\n  \n  Or you can use the `[]` syntax to denote optionality.\n  \n    connect(\n        escort(function(routes) {\n            routes.get(\"/data[.{format}]\", function(req, res, params) {\n                var format = params.format || \"html\";\n                \n                switch (format) {\n                    case \"html\":\n                        res.end(\"<p>Hey there</p>\");\n                        break;\n                    case \"json\":\n                        res.end(JSON.stingify(\"Hey there\"));\n                        break;\n                    default:\n                        res.writeHead(404);\n                        res.end();\n                        break;\n                }\n            })\n        })\n    ).listen(3000);\n  \n  _Note: a better way of determining what format someone wants is to check their Accept header, so I recommend you do\n  that for your non-example apps._\n\n## Unicode\n  \n  You can have unicode (non-ASCII) characters in both the literal segments of your paths as well as in the dynamic\n  segments of your path.\n  \n    var url;\n    connect(\n        escort(function(routes) {\n            url = routes.url;\n            \n            routes.get(\"uber\", \"/über\", function(req, res) {\n                res.end(\"You're super-cool.\");\n            });\n            routes.get(\"post\", \"/posts/{name:string({allowNonASCII: true})}\", function(req, res, params) {\n                res.end(\"You hit the \" + params.name + \" post\");\n            });\n        })\n    ).listen(3000);\n    \n    url.uber() === \"/%C3%BCber\";\n    url.post(\"cliché\") === \"/posts/clich%C3%A9\";\n  \n  Visiting `/über`, which is actually `/%C3%BCber`, will respond with \"You're super-cool\".\n  \n  Visiting `/posts/cliché`, which is actually `/posts/clich%C3%A9`, will respond with \"You hit the cliché post\".\n  \n  All the URL encoding and decoding is transparently taken care of without issue.\n\n## Not Found (404).\n  \n  By default, the `notFound` handler passes to the next middleware, which has an opportunity to handle it.\n  \n  If instead of having another middleware handle, you want to handle it yourself, it is quite simple:\n  \n    connect(\n        escort(function(routes) {\n            routes.get(\"/\", function(req, res) {\n                res.end(\"Welcome!\");\n            });\n            \n            routes.notFound(function(req, res, next) {\n                res.writeHead(404);\n                res.end(\"Sorry, that cannot be found.\");\n            });\n        })\n    ).listen(3000);\n  \n  Now visiting `/` will properly tell you `\"Welcome!\"`, but visiting any other URL will give you your custom 404.\n\n### Data-driven Not Founds\n\n  Often, you may have a route with parameters that requires data to be pulled down from a database. In the event that\n  the item you are retrieving does not exist, you should be properly returning a 404 Not Found. Rather than having to\n  replicate the logic of your Not Found handler, you can simply call `next` which will pass on to the next middleware\n  (or your defined Not Found handler).\n  \n    connect(\n        escort(function(routes) {\n            routes.get(\"/posts/{slug}\", function(req, res, params, next) {\n                Post.findOne({ slug: params.slug }, function(err, post) {\n                    if (err) {\n                        // an error occurred, pass it to the next middleware to throw a 500.\n                        return next(err);\n                    } else if (post === null) {\n                        // we didn't get a result back\n                        return next();\n                    }\n                    \n                    res.end(\"Retrieved post: \" + post);\n                })\n            });\n        })\n    ).listen(3000);\n\n## Method Not Allowed (405).\n  \n  By default, the `methodNotAllowed` handler returns a 405 to the user with no body, which would not be appropriate in\n  an HTML application. It might be in a JSON-based app, but that's up to you.\n  \n    connect(\n        escort(function(routes) {\n            url = routes.url;\n            \n            routes.get(\"/\", function(req, res) {\n                res.end(\"Welcome!\");\n            });\n            \n            routes.methodNotAllowed(function(req, res, next) {\n                res.writeHead(405);\n                res.end(\"The method \" + req.method + \" is not allowed on \" + req.url + \".\");\n            });\n        })\n    ).listen(3000);\n  \n  Now issuing a `GET` to `/` will properly tell you `\"Welcome!\"`, but issuing a `POST` or any undefined method will\n  go through the custom handler.\n\n## Code structuring\n\n  For small apps, it's easy to put all your routes inline, but once things get big enough, that can be very troublesome\n  maintenance-wise.\n  \n  Here is one way for how you can structure your app and retain your sanity.\n  \n  In `main.js`:\n    var connect = require('connect'),\n        escort = require('escort');\n      \n    connect(\n        escort(function(routes) {\n            require('./routes/home')(routes);\n            \n            routes.submount(\"/forums\", function(forums) {\n                require('./routes/forums')(forums);\n            });\n\n            routes.submount(\"/pages\", function(pages) {\n                require('./routes/forums')(pages);\n            });\n\n            routes.submount(\"/users\", function(users) {\n                require('./routes/users')(users);\n            });\n        })\n    ).listen(3000);\n  \n  In `routes/users.js`:\n    module.exports = function(routes) {\n        routes.get(\"users\", \"/\", function(req, res) {\n            res.end(\"User listing\");\n        });\n        \n        routes.get(\"user\", \"/{username}\", function(req, res, params) {\n            res.end(\"User details: \" + params.username);\n        });\n    };\n  \n  Of course, you're free to structure your app however you like.\n\n## Running without Connect\n  Some of you may be wondering how to use Escort's routing framework without having to use\n  [Connect](https://github.com/senchalabs/connect). It's not actually required or even used by Escort, it merely\n  provides an interface that Connect accepts.\n  \n  If you do have the desire to run without Connect, the following code is an example of doing so:\n  \n    var http = require('http'),\n        escort = require('escort');\n    \n    var routing = escort(function(routes) {\n        routes.get(\"/\", function(req, res) {\n            res.end(\"Welcome!\");\n        })\n    });\n    http.createServer(function(req, res) {\n        escort(req, res);\n    }).listen(3000);\n  \n  This provides a very simplistic default 404 and error handler, but works without issue.\n\n## Using with Express\n  Express is built on top of Connect, but it tends to expect that You'll be using the connect.router routing framework.\n  This is very easy to overcome, though.\n  \n    var express = require(\"express\"),\n        escort = require(\"escort\");\n\n    var app = express.createServer();\n\n    var routing = escort();\n\n    app.dynamicHelpers({\n        url: routing.url,\n        messages: messages\n    });\n\n    app.configure(function () {\n        app.use(express.logger('\\x1b[33m:method\\x1b[0m \\x1b[32m:url\\x1b[0m :response-time'));\n        app.use(express.bodyParser());\n        app.use(express.methodOverride());\n        app.use(express.cookieParser());\n        app.use(express.session({ secret: 'keyboard cat' }));\n        app.use(routing);\n        app.use(express.static(__dirname + '/public'));\n        app.use(express.errorHandler({ dumpExceptions: true, showStack: true }));\n    });\n\n    routing.get('/', function (req, res) {\n        res.render('index', {\n            message: \"Hello, world\"\n        });\n    });\n\n    if (!module.parent) {\n        app.listen(3000);\n        console.log('Express started on port 3000');\n    }\n  \n  The only real differences from a typical *Hello world* app using Express is that:\n  \n  * `routing` is declared before `app.configure` (but not the configuration of it).\n  * `routing` is passed into `app.configure` instead of `app.router`.\n  * `routing.get` is used instead of `app.get`.\n  * `url` is provided to `dynamicHelpers`. This is optional, but nice inside views.\n\n## Client-side URL generation\n  \n  First, you'll need to serialize the URL structure of your webapp. This can be done at any point in your app's\n  lifecycle, even in its own exposed route, as long as it occurs after configuration.\n  \n  As you may notice, the URL generation API is the exact same once the `url` object has been created.\n\n### In-development example\n  For development, it may be handy to have your URL JSON dump accessible by its own route, but once you go into\n  production/staging, I strongly recommend placing the serialized dump directly into your client javascript files.\n  \n  Node.js code\n  \n    connect(\n        escort(function() {\n            this.get(\"root\", \"/\", function(req, res) {\n                res.end(\"GET /\");\n            });\n            \n            this.get(\"post\", \"/{post}\", function(req, res, params) {\n                res.end(\"GET /\" + params.post);\n            });\n            \n            if (process.env.NODE_ENV !== \"production\") {\n                // we only want to expose this during development\n                \n                var serialize = this.serialize;\n                this.get(\"routeExport\", \"/routes.js\", function(req, res) {\n                    res.writeHead(200, {\"Content-Type\", \"text/javascript\"});\n                    res.end(\"window.url = escortClient.generateUrlObject(\" + JSON.stringify(serialize()) + \")\");\n                });\n            }\n        })\n    ).listen(3000);\n  \n  Browser HTML code\n  \n    <script src=\"/static/scripts/escort-client.js\"></script>\n    <script src=\"/routes.js\"></script>\n    <script>\n        url.root() === \"/\";\n        url.post(\"hey\") === \"/hey\";\n        url.post({ post: \"hey\" }) === \"/hey\";\n    </script>\n\n### Production example\n  You'll actually want to concatenate all your scripts as well as minify them when launching your production app, but\n  I'm leaving that part out for clarity.\n  \n  The Node.js code is the same as above, since `/routes.js` is not available during production.\n  \n  Browser Javascript code (url-routes.js)\n  \n    // sticking this on the global window object is probably a bad idea.\n    window.url = escortClient.generateUrlObject(/* paste your blob into here */);\n  \n  Browser HTML code\n  \n    <script src=\"/static/scripts/escort-client.js\"></script>\n    <script src=\"/static/scripts/url-routes.js\"></script>\n    <script>\n        url.root() === \"/\";\n        url.post(\"hey\") === \"/hey\";\n        url.post({ post: \"hey\" }) === \"/hey\";\n    </script>\n\n## Running Tests\n\nfirst:\n\n    $ git submodule update --init\n\nthen:\n\n    $ make test\n\n## Issues\n\n  If you find any issues with Escort or have any suggestions or feedback, please feel free to visit the [github\n  issues](https://github.com/ckknight/escort/issues) page.\n\n## License\n\nMIT licensed. See [LICENSE](https://github.com/ckknight/escort/blob/master/LICENSE) for more details.\n",
  "_id": "escort@0.0.13",
  "_from": "escort"
}
